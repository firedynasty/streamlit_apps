<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess Analyzer - Stockfish.js</title>
    <style>
        * {
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #1a1a2e;
            color: #eee;
        }
        h1 {
            color: #00d4ff;
            text-align: center;
        }
        .status-bar {
            background: #16213e;
            padding: 10px 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .status-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ff6b6b;
        }
        .status-dot.ready {
            background: #51cf66;
        }
        .status-dot.working {
            background: #ffd43b;
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        @media (max-width: 800px) {
            .container {
                grid-template-columns: 1fr;
            }
        }
        .panel {
            background: #16213e;
            padding: 20px;
            border-radius: 12px;
        }
        .panel h2 {
            margin-top: 0;
            color: #00d4ff;
            font-size: 1.2em;
            border-bottom: 1px solid #0f3460;
            padding-bottom: 10px;
        }
        textarea {
            width: 100%;
            height: 200px;
            background: #0f3460;
            border: 1px solid #1a1a2e;
            color: #eee;
            padding: 12px;
            border-radius: 8px;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 13px;
            resize: vertical;
        }
        textarea:focus {
            outline: none;
            border-color: #00d4ff;
        }
        input[type="text"] {
            width: 100%;
            background: #0f3460;
            border: 1px solid #1a1a2e;
            color: #eee;
            padding: 12px;
            border-radius: 8px;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 13px;
        }
        input[type="text"]:focus {
            outline: none;
            border-color: #00d4ff;
        }
        button {
            background: #00d4ff;
            color: #1a1a2e;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            margin-top: 10px;
            transition: background 0.2s;
        }
        button:hover {
            background: #00b8e6;
        }
        button:disabled {
            background: #555;
            cursor: not-allowed;
        }
        .settings {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }
        .setting-group label {
            display: block;
            font-size: 12px;
            color: #888;
            margin-bottom: 4px;
        }
        .setting-group input, .setting-group select {
            width: 100%;
            background: #0f3460;
            border: 1px solid #1a1a2e;
            color: #eee;
            padding: 8px;
            border-radius: 6px;
        }
        .results {
            margin-top: 20px;
        }
        .result-item {
            background: #0f3460;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 10px;
            border-left: 4px solid #00d4ff;
        }
        .result-item.blunder {
            border-left-color: #ff6b6b;
        }
        .result-item.mistake {
            border-left-color: #ffa94d;
        }
        .result-item.inaccuracy {
            border-left-color: #ffd43b;
        }
        .result-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
        }
        .move-info {
            font-weight: bold;
        }
        .eval-change {
            font-family: monospace;
            color: #888;
        }
        .severity {
            font-size: 11px;
            padding: 2px 8px;
            border-radius: 4px;
            font-weight: bold;
        }
        .severity.blunder {
            background: #ff6b6b;
            color: #1a1a2e;
        }
        .severity.mistake {
            background: #ffa94d;
            color: #1a1a2e;
        }
        .severity.inaccuracy {
            background: #ffd43b;
            color: #1a1a2e;
        }
        .fen-link {
            font-size: 12px;
            color: #00d4ff;
            text-decoration: none;
        }
        .fen-link:hover {
            text-decoration: underline;
        }
        .progress-bar {
            width: 100%;
            height: 6px;
            background: #0f3460;
            border-radius: 3px;
            overflow: hidden;
            margin-top: 10px;
        }
        .progress-fill {
            height: 100%;
            background: #00d4ff;
            width: 0%;
            transition: width 0.3s;
        }
        .stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 15px;
        }
        .stat-box {
            background: #0f3460;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }
        .stat-value {
            font-size: 24px;
            font-weight: bold;
        }
        .stat-label {
            font-size: 12px;
            color: #888;
        }
        .stat-box.blunders .stat-value { color: #ff6b6b; }
        .stat-box.mistakes .stat-value { color: #ffa94d; }
        .stat-box.inaccuracies .stat-value { color: #ffd43b; }
        #log {
            height: 150px;
            overflow-y: auto;
            font-size: 12px;
            background: #0a0a15;
            padding: 10px;
            border-radius: 8px;
            font-family: monospace;
        }
        .log-entry {
            margin-bottom: 4px;
            color: #888;
        }
        .log-entry.info { color: #00d4ff; }
        .log-entry.success { color: #51cf66; }
        .log-entry.error { color: #ff6b6b; }
        .log-entry.warning { color: #ffd43b; }
    </style>
</head>
<body>
    <h1>Chess Game Analyzer</h1>
    <p style="text-align: center; color: #888;">Powered by Stockfish.js (runs in your browser - no server needed!)</p>

    <div class="status-bar">
        <div class="status-indicator">
            <div class="status-dot" id="statusDot"></div>
            <span id="statusText">Loading Stockfish...</span>
        </div>
        <div id="engineInfo" style="color: #888; font-size: 12px;"></div>
    </div>

    <div class="container">
        <div class="panel">
            <h2>Input</h2>

            <div class="settings">
                <div class="setting-group">
                    <label>Analysis Depth</label>
                    <select id="depth">
                        <option value="10" selected>10 (Fast ~2s/move)</option>
                        <option value="12">12 (Balanced ~4s/move)</option>
                        <option value="15">15 (Accurate ~8s/move)</option>
                        <option value="18">18 (Deep ~15s/move)</option>
                    </select>
                </div>
                <div class="setting-group">
                    <label>Engine Source</label>
                    <select id="engineSource">
                        <option value="lichess" selected>Lichess Cloud (Fast)</option>
                        <option value="stockfish">Stockfish.js (Client)</option>
                    </select>
                </div>
            </div>

            <label style="display: block; margin-bottom: 8px; color: #888; font-size: 12px;">
                Paste PGN or moves (e.g., 1. e4 e5 2. Nf3 Nc6)
            </label>
            <textarea id="pgnInput" placeholder="1. e4 e5 2. Nf3 Nc6 3. Bb5 a6 4. Ba4 Nf6 5. O-O Be7 6. Re1 b5 7. Bb3 d6 8. c3 O-O"></textarea>

            <div style="margin-top: 15px;">
                <label style="display: block; margin-bottom: 8px; color: #888; font-size: 12px;">
                    Or analyze a single position (FEN)
                </label>
                <input type="text" id="fenInput" placeholder="rnbqkbnr/pppppppp/8/8/4P3/8/PPPP1PPP/RNBQKBNR b KQkq e3 0 1">
            </div>

            <div style="margin-top: 15px;">
                <button id="analyzeBtn" onclick="analyzeGame()" disabled>Analyze Game</button>
                <button id="analyzeFenBtn" onclick="analyzeFen()" disabled style="background: #0f3460; color: #00d4ff;">Analyze Position</button>
                <button onclick="clearResults()" style="background: #333; color: #888;">Clear</button>
            </div>

            <div class="progress-bar" id="progressBar" style="display: none;">
                <div class="progress-fill" id="progressFill"></div>
            </div>
        </div>

        <div class="panel">
            <h2>Results</h2>

            <div id="openingInfo" style="display: none; background: #0f3460; padding: 12px; border-radius: 8px; margin-bottom: 15px;">
                <div style="font-size: 12px; color: #888; margin-bottom: 4px;">Opening</div>
                <div style="font-weight: bold; color: #00d4ff;" id="openingName">-</div>
            </div>

            <div id="openingDeviations" style="display: none; margin-bottom: 15px;"></div>

            <div class="stats" id="statsContainer" style="display: none;">
                <div class="stat-box blunders">
                    <div class="stat-value" id="blunderCount">0</div>
                    <div class="stat-label">Blunders</div>
                </div>
                <div class="stat-box mistakes">
                    <div class="stat-value" id="mistakeCount">0</div>
                    <div class="stat-label">Mistakes</div>
                </div>
                <div class="stat-box inaccuracies">
                    <div class="stat-value" id="inaccuracyCount">0</div>
                    <div class="stat-label">Inaccuracies</div>
                </div>
            </div>

            <div class="results" id="results">
                <p style="color: #888; text-align: center;">Enter a PGN and click Analyze to see results</p>
            </div>
        </div>
    </div>

    <div class="panel" style="margin-top: 20px;">
        <h2>Log</h2>
        <div id="log"></div>
    </div>

    <!-- Chess.js for move parsing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>

    <script>
        // =====================================================================
        // STOCKFISH.JS CLIENT-SIDE ENGINE
        // =====================================================================

        let stockfish = null;
        let isReady = false;
        let currentResolve = null;
        let analysisQueue = [];

        // Thresholds (in centipawns)
        const BLUNDER_THRESHOLD = -200;
        const MISTAKE_THRESHOLD = -100;
        const INACCURACY_THRESHOLD = -50;

        // Initialize Stockfish Web Worker
        function initStockfish() {
            log('Initializing Stockfish.js...', 'info');

            // Use local stockfish.js file (must be served from same origin)
            // Download from: https://unpkg.com/stockfish.js@10.0.2/stockfish.js

            try {
                // Load from local file (same directory as this HTML)
                stockfish = new Worker('stockfish.js');

                stockfish.onmessage = handleStockfishMessage;
                stockfish.onerror = (e) => {
                    log('Stockfish error: ' + e.message, 'error');
                };

                // Initialize UCI
                stockfish.postMessage('uci');

            } catch (e) {
                log('Failed to load Stockfish: ' + e.message, 'error');
                setStatus('error', 'Failed to load engine');
            }
        }

        function handleStockfishMessage(e) {
            const line = e.data;

            if (line === 'uciok') {
                log('Stockfish UCI initialized', 'success');
                stockfish.postMessage('isready');
            }
            else if (line === 'readyok') {
                isReady = true;
                setStatus('ready', 'Stockfish ready');
                document.getElementById('analyzeBtn').disabled = false;
                document.getElementById('analyzeFenBtn').disabled = false;
                document.getElementById('engineInfo').textContent = 'Stockfish.js (Client-side WASM)';
                log('Stockfish is ready!', 'success');
            }
            else if (line.startsWith('info depth')) {
                // Parse evaluation info
                const depthMatch = line.match(/depth (\d+)/);
                const scoreMatch = line.match(/score (cp|mate) (-?\d+)/);
                const pvMatch = line.match(/pv (.+)/);

                if (depthMatch && scoreMatch) {
                    const depth = parseInt(depthMatch[1]);
                    const scoreType = scoreMatch[1];
                    const scoreValue = parseInt(scoreMatch[2]);

                    // Update during analysis
                    if (depth >= 10) {
                        const evalStr = scoreType === 'mate'
                            ? `M${scoreValue}`
                            : (scoreValue / 100).toFixed(2);
                        // Could update UI here with intermediate results
                    }
                }
            }
            else if (line.startsWith('bestmove')) {
                // Analysis complete
                const bestMove = line.split(' ')[1];

                if (currentResolve) {
                    currentResolve({
                        bestMove: bestMove,
                        evaluation: currentEval
                    });
                    currentResolve = null;
                }
            }
        }

        let currentEval = 0;

        // Analyze a single position
        function analyzePosition(fen, targetDepth = 10) {
            return new Promise((resolve, reject) => {
                if (!isReady) {
                    reject(new Error('Stockfish not ready'));
                    return;
                }

                let finalEval = 0;
                let currentDepth = 0;

                const analysisHandler = (e) => {
                    const line = e.data;

                    // Capture evaluation at each depth
                    if (line.startsWith('info depth')) {
                        const depthMatch = line.match(/info depth (\d+)/);
                        const scoreMatch = line.match(/score (cp|mate) (-?\d+)/);

                        if (depthMatch && scoreMatch) {
                            const depth = parseInt(depthMatch[1]);
                            const scoreType = scoreMatch[1];
                            const scoreValue = parseInt(scoreMatch[2]);

                            // Only update if this is a deeper search
                            if (depth >= currentDepth) {
                                currentDepth = depth;
                                finalEval = scoreType === 'mate'
                                    ? (scoreValue > 0 ? 10000 - scoreValue : -10000 - scoreValue)
                                    : scoreValue;
                            }
                        }
                    }

                    // Analysis complete
                    if (line.startsWith('bestmove')) {
                        // Restore original handler
                        stockfish.onmessage = handleStockfishMessage;

                        resolve({
                            evaluation: finalEval,
                            depth: currentDepth
                        });
                    }
                };

                // Set up handler for this analysis
                stockfish.onmessage = analysisHandler;

                // Set up position and analyze
                stockfish.postMessage('position fen ' + fen);
                stockfish.postMessage('go depth ' + targetDepth);

                // Timeout after 30 seconds
                setTimeout(() => {
                    stockfish.postMessage('stop');
                }, 30000);
            });
        }

        // =====================================================================
        // LICHESS OPENING EXPLORER API
        // =====================================================================

        async function getOpeningName(fen) {
            try {
                // Lichess Opening Explorer API - returns opening name + stats
                const response = await fetch(
                    `https://explorer.lichess.ovh/masters?fen=${encodeURIComponent(fen)}`
                );

                if (!response.ok) return null;

                const data = await response.json();

                if (data.opening) {
                    return {
                        eco: data.opening.eco,
                        name: data.opening.name
                    };
                }
                return null;
            } catch (e) {
                return null;
            }
        }

        async function getOpeningMoves(fen) {
            try {
                // Get top moves from master database
                const response = await fetch(
                    `https://explorer.lichess.ovh/masters?fen=${encodeURIComponent(fen)}&topGames=0`
                );

                if (!response.ok) return null;

                const data = await response.json();

                if (data.moves && data.moves.length > 0) {
                    // Return top moves with their play rates
                    const totalGames = data.white + data.draws + data.black;
                    return {
                        moves: data.moves.slice(0, 5).map(m => ({
                            san: m.san,
                            games: m.white + m.draws + m.black,
                            percentage: totalGames > 0
                                ? ((m.white + m.draws + m.black) / totalGames * 100).toFixed(1)
                                : 0,
                            whiteWinRate: m.white + m.draws + m.black > 0
                                ? ((m.white / (m.white + m.draws + m.black)) * 100).toFixed(0)
                                : 0
                        })),
                        totalGames: totalGames,
                        opening: data.opening
                    };
                }
                return null;
            } catch (e) {
                return null;
            }
        }

        // =====================================================================
        // LICHESS CLOUD EVAL
        // =====================================================================

        async function lichessCloudEval(fen) {
            try {
                const response = await fetch(
                    `https://lichess.org/api/cloud-eval?fen=${encodeURIComponent(fen)}&multiPv=1`
                );

                if (response.status === 404) {
                    return null; // Not in cloud database
                }

                const data = await response.json();

                if (data.pvs && data.pvs[0]) {
                    const pv = data.pvs[0];
                    let score;

                    if (pv.mate !== undefined) {
                        score = pv.mate > 0 ? 10000 - pv.mate : -10000 - pv.mate;
                    } else {
                        score = pv.cp || 0;
                    }

                    return {
                        score: score,
                        bestMove: pv.moves ? pv.moves.split(' ')[0] : null,
                        source: 'lichess_cloud',
                        depth: data.depth
                    };
                }

                return null;
            } catch (e) {
                log('Lichess API error: ' + e.message, 'warning');
                return null;
            }
        }

        // =====================================================================
        // GAME ANALYSIS
        // =====================================================================

        function cleanPgn(pgn) {
            // Remove NAG annotations ($1, $2, $4, $6, $9, etc.)
            let cleaned = pgn.replace(/\$\d+/g, '');
            // Remove comments in curly braces {comment}
            cleaned = cleaned.replace(/\{[^}]*\}/g, '');
            // Remove comments in parentheses (variations)
            cleaned = cleaned.replace(/\([^)]*\)/g, '');
            // Remove clock annotations [%clk ...]
            cleaned = cleaned.replace(/\[%[^\]]*\]/g, '');
            // Clean up extra whitespace
            cleaned = cleaned.replace(/\s+/g, ' ').trim();
            return cleaned;
        }

        async function analyzeGame() {
            let pgn = document.getElementById('pgnInput').value.trim();
            if (!pgn) {
                log('Please enter a PGN', 'error');
                return;
            }

            // Clean PGN of annotations
            pgn = cleanPgn(pgn);
            log('Cleaned PGN of annotations', 'info');

            const depth = parseInt(document.getElementById('depth').value);
            const useCloud = document.getElementById('engineSource').value === 'lichess';

            document.getElementById('analyzeBtn').disabled = true;
            document.getElementById('progressBar').style.display = 'block';
            document.getElementById('statsContainer').style.display = 'grid';
            document.getElementById('results').innerHTML = '<p style="color: #888;">Analyzing...</p>';

            setStatus('working', 'Analyzing...');
            log('Starting game analysis...', 'info');

            try {
                const chess = new Chess();

                // Try to load PGN
                if (!chess.load_pgn(pgn)) {
                    // If PGN load fails, try parsing as move list
                    chess.reset();
                    const moves = pgn.replace(/\d+\./g, '').trim().split(/\s+/);
                    for (const move of moves) {
                        if (move && !chess.move(move)) {
                            throw new Error(`Invalid move: ${move}`);
                        }
                    }
                }

                const history = chess.history({ verbose: true });
                const totalMoves = history.length;

                log(`Parsed ${totalMoves} moves`, 'info');

                // Detect opening and deviations from theory
                let openingInfo = null;
                let openingDeviations = [];
                let leftBook = false;
                let leftBookAtMove = null;

                const tempChess = new Chess();
                for (let i = 0; i < Math.min(history.length, 30); i++) {
                    const fenBefore = tempChess.fen();
                    const movePlayed = history[i].san;
                    const moveNum = Math.floor(i / 2) + 1;
                    const isWhite = i % 2 === 0;
                    const notation = isWhite ? `${moveNum}.` : `${moveNum}...`;

                    // Get book moves for this position
                    const bookData = await getOpeningMoves(fenBefore);

                    tempChess.move(movePlayed);

                    // Update opening name
                    const opening = await getOpeningName(tempChess.fen());
                    if (opening) {
                        openingInfo = opening;
                    }

                    // Check if move is in book
                    if (bookData && bookData.moves.length > 0 && !leftBook) {
                        const bookMoves = bookData.moves.map(m => m.san);
                        const isBookMove = bookMoves.includes(movePlayed);
                        const topMove = bookData.moves[0];

                        if (!isBookMove) {
                            // Player deviated from book!
                            leftBook = true;
                            leftBookAtMove = notation;

                            const mainLineMoves = bookData.moves.slice(0, 3)
                                .map(m => `${m.san} (${m.percentage}%)`)
                                .join(', ');

                            openingDeviations.push({
                                notation: notation,
                                movePlayed: movePlayed,
                                isWhite: isWhite,
                                mainLine: topMove.san,
                                mainLinePercentage: topMove.percentage,
                                alternatives: mainLineMoves,
                                totalGames: bookData.totalGames,
                                fen: fenBefore
                            });

                            log(`${notation} ${movePlayed}: Left opening theory! Main line was ${topMove.san} (${topMove.percentage}%)`, 'warning');
                        }
                    } else if (!bookData || bookData.moves.length === 0) {
                        // No more book moves - we're out of theory
                        if (!leftBook) {
                            leftBook = true;
                            leftBookAtMove = notation;
                        }
                    }
                }

                if (openingInfo) {
                    log(`Opening: ${openingInfo.eco} - ${openingInfo.name}`, 'success');
                }
                if (leftBookAtMove && openingDeviations.length === 0) {
                    log(`Left book at move ${leftBookAtMove} (end of theory)`, 'info');
                }

                // Reset for analysis
                chess.reset();

                const mistakes = [];
                let blunders = 0, mistakeCount = 0, inaccuracies = 0;
                let prevEval = 0;

                // First pass: analyze all positions (only once each)
                log('Analyzing all positions...', 'info');
                const evaluations = [];

                // Analyze starting position
                let result;
                if (useCloud) {
                    const cloudResult = await lichessCloudEval(chess.fen());
                    result = cloudResult ? cloudResult.score : 0;
                } else {
                    const sfResult = await analyzePosition(chess.fen(), depth);
                    result = sfResult.evaluation;
                }
                evaluations.push(result);

                // Analyze after each move
                for (let i = 0; i < history.length; i++) {
                    chess.move(history[i].san);

                    if (useCloud) {
                        const cloudResult = await lichessCloudEval(chess.fen());
                        result = cloudResult ? cloudResult.score : 0;
                    } else {
                        const sfResult = await analyzePosition(chess.fen(), depth);
                        result = sfResult.evaluation;
                    }
                    evaluations.push(result);

                    // Update progress
                    const progress = ((i + 1) / totalMoves) * 100;
                    document.getElementById('progressFill').style.width = progress + '%';
                }

                // Reset for second pass
                chess.reset();

                // Second pass: compare evaluations to find mistakes
                log('Identifying mistakes...', 'info');
                for (let i = 0; i < history.length; i++) {
                    const move = history[i];
                    const moveNum = Math.floor(i / 2) + 1;
                    const isWhite = i % 2 === 0;
                    const notation = isWhite ? `${moveNum}.` : `${moveNum}...`;

                    const fenBefore = chess.fen();

                    let evalBefore = evaluations[i];
                    let evalAfter = evaluations[i + 1];

                    // Calculate swing based on engine source
                    let swing;
                    let evalBeforeForDisplay, evalAfterForDisplay;

                    if (useCloud) {
                        // LICHESS CLOUD: Returns eval from WHITE's perspective always
                        // positive = good for white, negative = good for black
                        //
                        // For WHITE's move: swing = evalAfter - evalBefore
                        //   Good move: evalAfter > evalBefore (position improved for white)
                        //
                        // For BLACK's move: swing = evalBefore - evalAfter
                        //   Good move for black: evalAfter < evalBefore (position got worse for white = better for black)

                        if (isWhite) {
                            swing = evalAfter - evalBefore;
                            evalBeforeForDisplay = evalBefore;
                            evalAfterForDisplay = evalAfter;
                        } else {
                            swing = evalBefore - evalAfter;
                            // For black, show from black's perspective (negate)
                            evalBeforeForDisplay = -evalBefore;
                            evalAfterForDisplay = -evalAfter;
                        }
                    } else {
                        // STOCKFISH.JS: Returns eval from SIDE-TO-MOVE's perspective
                        // evalBefore: from moving side's view
                        // evalAfter: from opponent's view, so negate it
                        const evalAfterFromMovingSide = -evalAfter;
                        swing = evalAfterFromMovingSide - evalBefore;
                        evalBeforeForDisplay = evalBefore;
                        evalAfterForDisplay = evalAfterFromMovingSide;
                    }

                    // Make the move for next iteration
                    chess.move(move.san);

                    // Classify
                    let severity = null;
                    if (swing <= BLUNDER_THRESHOLD) {
                        severity = 'BLUNDER';
                        blunders++;
                    } else if (swing <= MISTAKE_THRESHOLD) {
                        severity = 'MISTAKE';
                        mistakeCount++;
                    } else if (swing <= INACCURACY_THRESHOLD) {
                        severity = 'INACCURACY';
                        inaccuracies++;
                    }

                    if (severity) {
                        mistakes.push({
                            notation: notation,
                            move: move.san,
                            severity: severity,
                            evalBefore: evalBeforeForDisplay,
                            evalAfter: evalAfterForDisplay,
                            swing: swing,
                            fen: fenBefore
                        });
                        log(`${notation} ${move.san}: ${severity} (${swing} cp)`,
                            severity === 'BLUNDER' ? 'error' : 'warning');
                    }
                }

                // Update opening info
                if (openingInfo) {
                    document.getElementById('openingInfo').style.display = 'block';
                    document.getElementById('openingName').textContent = `${openingInfo.eco}: ${openingInfo.name}`;
                } else {
                    document.getElementById('openingInfo').style.display = 'none';
                }

                // Display opening deviations
                const deviationsEl = document.getElementById('openingDeviations');
                if (openingDeviations.length > 0) {
                    let html = `
                        <div style="background: #1a1a2e; border: 1px solid #ffa94d; border-radius: 8px; padding: 12px;">
                            <div style="font-size: 12px; color: #ffa94d; margin-bottom: 8px; font-weight: bold;">
                                Opening Deviation
                            </div>
                    `;

                    for (const dev of openingDeviations) {
                        const fenEncoded = dev.fen.replace(/ /g, '_');
                        html += `
                            <div style="background: #0f3460; padding: 10px; border-radius: 6px; margin-bottom: 8px;">
                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                    <span style="font-weight: bold;">${dev.notation} ${dev.movePlayed}</span>
                                    <span style="font-size: 11px; background: #ffa94d; color: #1a1a2e; padding: 2px 6px; border-radius: 4px;">
                                        OUT OF BOOK
                                    </span>
                                </div>
                                <div style="margin-top: 8px; font-size: 13px; color: #aaa;">
                                    Main line: <strong style="color: #51cf66;">${dev.mainLine}</strong>
                                    <span style="color: #888;">(${dev.mainLinePercentage}% of ${dev.totalGames.toLocaleString()} master games)</span>
                                </div>
                                <div style="margin-top: 4px; font-size: 12px; color: #888;">
                                    Theory: ${dev.alternatives}
                                </div>
                                <div style="margin-top: 8px;">
                                    <a href="https://lichess.org/analysis/${fenEncoded}" target="_blank"
                                       style="font-size: 12px; color: #00d4ff; text-decoration: none;">
                                        Study this position on Lichess
                                    </a>
                                </div>
                            </div>
                        `;
                    }

                    html += '</div>';
                    deviationsEl.innerHTML = html;
                    deviationsEl.style.display = 'block';
                } else {
                    deviationsEl.style.display = 'none';
                }

                // Update stats
                document.getElementById('blunderCount').textContent = blunders;
                document.getElementById('mistakeCount').textContent = mistakeCount;
                document.getElementById('inaccuracyCount').textContent = inaccuracies;

                // Display results
                displayResults(mistakes);

                setStatus('ready', 'Analysis complete');
                log(`Analysis complete: ${blunders} blunders, ${mistakeCount} mistakes, ${inaccuracies} inaccuracies`, 'success');

            } catch (e) {
                log('Analysis error: ' + e.message, 'error');
                setStatus('ready', 'Error - check log');
            }

            document.getElementById('analyzeBtn').disabled = false;
            document.getElementById('progressBar').style.display = 'none';
        }

        async function analyzeFen() {
            const fen = document.getElementById('fenInput').value.trim();
            if (!fen) {
                log('Please enter a FEN', 'error');
                return;
            }

            document.getElementById('analyzeFenBtn').disabled = true;
            setStatus('working', 'Analyzing position...');
            log('Analyzing position: ' + fen, 'info');

            try {
                const depth = parseInt(document.getElementById('depth').value);
                const useCloud = document.getElementById('engineSource').value === 'lichess';

                let result;
                if (useCloud) {
                    result = await lichessCloudEval(fen);
                    if (!result) {
                        log('Position not in Lichess cloud, trying Stockfish...', 'warning');
                        result = await analyzePosition(fen, depth);
                        result = { score: result.evaluation, bestMove: result.bestMove };
                    }
                } else {
                    const sfResult = await analyzePosition(fen, depth);
                    result = { score: sfResult.evaluation, bestMove: sfResult.bestMove };
                }

                const evalStr = (result.score / 100).toFixed(2);
                document.getElementById('results').innerHTML = `
                    <div class="result-item">
                        <div class="result-header">
                            <span class="move-info">Position Evaluation</span>
                            <span class="eval-change">${result.score > 0 ? '+' : ''}${evalStr}</span>
                        </div>
                        <div>Best move: <strong>${result.bestMove || 'N/A'}</strong></div>
                        <div style="margin-top: 8px;">
                            <a class="fen-link" href="https://lichess.org/analysis/${fen.replace(/ /g, '_')}" target="_blank">
                                Analyze on Lichess
                            </a>
                        </div>
                    </div>
                `;

                log(`Evaluation: ${evalStr} | Best: ${result.bestMove}`, 'success');
                setStatus('ready', 'Analysis complete');

            } catch (e) {
                log('Error: ' + e.message, 'error');
                setStatus('ready', 'Error');
            }

            document.getElementById('analyzeFenBtn').disabled = false;
        }

        function displayResults(mistakes) {
            if (mistakes.length === 0) {
                document.getElementById('results').innerHTML =
                    '<p style="color: #51cf66; text-align: center;">Great game! No significant mistakes found.</p>';
                return;
            }

            let html = '';
            for (const m of mistakes) {
                const evalBeforeStr = (m.evalBefore / 100).toFixed(2);
                const evalAfterStr = (m.evalAfter / 100).toFixed(2);
                const fenEncoded = m.fen.replace(/ /g, '_');

                html += `
                    <div class="result-item ${m.severity.toLowerCase()}">
                        <div class="result-header">
                            <span class="move-info">${m.notation} ${m.move}</span>
                            <span class="severity ${m.severity.toLowerCase()}">${m.severity}</span>
                        </div>
                        <div class="eval-change">
                            ${evalBeforeStr} â†’ ${evalAfterStr} (${m.swing > 0 ? '+' : ''}${(m.swing/100).toFixed(2)})
                        </div>
                        <div style="margin-top: 8px;">
                            <a class="fen-link" href="https://lichess.org/analysis/${fenEncoded}" target="_blank">
                                Analyze this position on Lichess
                            </a>
                        </div>
                    </div>
                `;
            }

            document.getElementById('results').innerHTML = html;
        }

        function clearResults() {
            document.getElementById('results').innerHTML =
                '<p style="color: #888; text-align: center;">Enter a PGN and click Analyze to see results</p>';
            document.getElementById('statsContainer').style.display = 'none';
            document.getElementById('openingInfo').style.display = 'none';
            document.getElementById('openingDeviations').style.display = 'none';
            document.getElementById('blunderCount').textContent = '0';
            document.getElementById('mistakeCount').textContent = '0';
            document.getElementById('inaccuracyCount').textContent = '0';
            document.getElementById('progressFill').style.width = '0%';
        }

        // =====================================================================
        // UI HELPERS
        // =====================================================================

        function setStatus(status, text) {
            const dot = document.getElementById('statusDot');
            const textEl = document.getElementById('statusText');

            dot.className = 'status-dot';
            if (status === 'ready') dot.classList.add('ready');
            if (status === 'working') dot.classList.add('working');

            textEl.textContent = text;
        }

        function log(message, type = 'info') {
            const logEl = document.getElementById('log');
            const entry = document.createElement('div');
            entry.className = 'log-entry ' + type;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logEl.appendChild(entry);
            logEl.scrollTop = logEl.scrollHeight;
        }

        // Initialize on load
        window.onload = () => {
            log('Chess Analyzer loaded', 'info');
            initStockfish();
        };
    </script>
</body>
</html>
