<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess Analyzer - Stockfish.js</title>
    <!-- Chessboard.js CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.css">
    <style>
        * {
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #1a1a2e;
            color: #eee;
        }
        h1 {
            color: #00d4ff;
            text-align: center;
        }
        .status-bar {
            background: #16213e;
            padding: 10px 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .status-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ff6b6b;
        }
        .status-dot.ready {
            background: #51cf66;
        }
        .status-dot.working {
            background: #ffd43b;
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        @media (max-width: 800px) {
            .container {
                grid-template-columns: 1fr;
            }
        }
        .panel {
            background: #16213e;
            padding: 20px;
            border-radius: 12px;
        }
        .panel h2 {
            margin-top: 0;
            color: #00d4ff;
            font-size: 1.2em;
            border-bottom: 1px solid #0f3460;
            padding-bottom: 10px;
        }
        textarea {
            width: 100%;
            height: 200px;
            background: #0f3460;
            border: 1px solid #1a1a2e;
            color: #eee;
            padding: 12px;
            border-radius: 8px;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 13px;
            resize: vertical;
        }
        textarea:focus {
            outline: none;
            border-color: #00d4ff;
        }
        input[type="text"] {
            width: 100%;
            background: #0f3460;
            border: 1px solid #1a1a2e;
            color: #eee;
            padding: 12px;
            border-radius: 8px;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 13px;
        }
        input[type="text"]:focus {
            outline: none;
            border-color: #00d4ff;
        }
        button {
            background: #00d4ff;
            color: #1a1a2e;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            margin-top: 10px;
            transition: background 0.2s;
        }
        button:hover {
            background: #00b8e6;
        }
        button:disabled {
            background: #555;
            cursor: not-allowed;
        }
        .settings {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }
        .setting-group label {
            display: block;
            font-size: 12px;
            color: #888;
            margin-bottom: 4px;
        }
        .setting-group input, .setting-group select {
            width: 100%;
            background: #0f3460;
            border: 1px solid #1a1a2e;
            color: #eee;
            padding: 8px;
            border-radius: 6px;
        }
        .results {
            margin-top: 20px;
        }
        .result-item {
            background: #0f3460;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 10px;
            border-left: 4px solid #00d4ff;
        }
        .result-item.blunder {
            border-left-color: #ff6b6b;
        }
        .result-item.mistake {
            border-left-color: #ffa94d;
        }
        .result-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
        }
        .move-info {
            font-weight: bold;
        }
        .eval-change {
            font-family: monospace;
            color: #888;
        }
        .severity {
            font-size: 11px;
            padding: 2px 8px;
            border-radius: 4px;
            font-weight: bold;
        }
        .severity.blunder {
            background: #ff6b6b;
            color: #1a1a2e;
        }
        .severity.mistake {
            background: #ffa94d;
            color: #1a1a2e;
        }
        .fen-link {
            font-size: 12px;
            color: #00d4ff;
            text-decoration: none;
        }
        .fen-link:hover {
            text-decoration: underline;
        }
        .progress-bar {
            width: 100%;
            height: 6px;
            background: #0f3460;
            border-radius: 3px;
            overflow: hidden;
            margin-top: 10px;
        }
        .progress-fill {
            height: 100%;
            background: #00d4ff;
            width: 0%;
            transition: width 0.3s;
        }
        .stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 15px;
        }
        .stat-box {
            background: #0f3460;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }
        .stat-value {
            font-size: 24px;
            font-weight: bold;
        }
        .stat-label {
            font-size: 12px;
            color: #888;
        }
        .stat-box.blunders .stat-value { color: #ff6b6b; }
        .stat-box.mistakes .stat-value { color: #ffa94d; }
        #log {
            height: 150px;
            overflow-y: auto;
            font-size: 12px;
            background: #0a0a15;
            padding: 10px;
            border-radius: 8px;
            font-family: monospace;
        }
        .log-entry {
            margin-bottom: 4px;
            color: #888;
        }
        .log-entry.info { color: #00d4ff; }
        .log-entry.success { color: #51cf66; }
        .log-entry.error { color: #ff6b6b; }
        .log-entry.warning { color: #ffd43b; }

        /* Chess.com Import Styles */
        .chesscom-import-bar {
            background: #16213e;
            padding: 12px 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
        }
        .chesscom-import-bar label {
            color: #888;
            font-size: 13px;
        }
        .chesscom-import-bar input[type="text"] {
            background: #0f3460;
            border: 1px solid #1a1a2e;
            color: #eee;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 13px;
            min-width: 180px;
        }
        .chesscom-import-bar input[type="text"]:focus {
            outline: none;
            border-color: #00d4ff;
        }
        .chesscom-import-bar input[type="text"]::placeholder {
            color: #666;
        }
        #fetch-games-btn {
            background: #0f3460;
            color: #00d4ff;
            border: 1px solid #00d4ff;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 13px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.2s;
        }
        #fetch-games-btn:hover {
            background: #00d4ff;
            color: #1a1a2e;
        }
        #fetch-games-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        .num-games-select {
            background: #0f3460;
            border: 1px solid #1a1a2e;
            color: #eee;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 13px;
            cursor: pointer;
        }
        .num-games-select:focus {
            outline: none;
            border-color: #00d4ff;
        }
        .game-selection-container {
            background: #16213e;
            padding: 12px 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        .game-selection-container label {
            display: block;
            color: #888;
            font-size: 12px;
            margin-bottom: 8px;
        }
        #game-dropdown {
            width: 100%;
            background: #0f3460;
            border: 1px solid #1a1a2e;
            color: #eee;
            padding: 10px 12px;
            border-radius: 6px;
            font-size: 13px;
            cursor: pointer;
        }
        #game-dropdown:focus {
            outline: none;
            border-color: #00d4ff;
        }
        #game-details {
            margin-top: 12px;
            padding: 12px;
            background: #0f3460;
            border-radius: 6px;
            font-size: 13px;
            border-left: 3px solid #00d4ff;
        }
        #game-details p {
            margin: 4px 0;
            color: #ccc;
        }
        #game-details a {
            color: #00d4ff;
            text-decoration: none;
        }
        #game-details a:hover {
            text-decoration: underline;
        }
        .chesscom-message {
            padding: 10px 12px;
            border-radius: 6px;
            margin-top: 10px;
            font-size: 13px;
        }
        .chesscom-message.error {
            background: rgba(255, 107, 107, 0.2);
            color: #ff6b6b;
            border: 1px solid #ff6b6b;
        }
        .chesscom-message.success {
            background: rgba(81, 207, 102, 0.2);
            color: #51cf66;
            border: 1px solid #51cf66;
        }
        .chesscom-message.info {
            background: rgba(0, 212, 255, 0.2);
            color: #00d4ff;
            border: 1px solid #00d4ff;
        }
        .chesscom-spinner {
            display: inline-block;
            width: 14px;
            height: 14px;
            border: 2px solid #0f3460;
            border-top: 2px solid #00d4ff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <h1>Chess Game Analyzer</h1>
    <p style="text-align: center; color: #888;">Powered by Stockfish.js (runs in your browser - no server needed!)</p>

    <div class="status-bar">
        <div class="status-indicator">
            <div class="status-dot" id="statusDot"></div>
            <span id="statusText">Loading Stockfish...</span>
        </div>
        <div id="engineInfo" style="color: #888; font-size: 12px;"></div>
    </div>

    <!-- Chess.com Import Section -->
    <div class="chesscom-import-bar" id="chesscom-import-bar">
        <label for="chesscom-username">Chess.com:</label>
        <input type="text" id="chesscom-username" placeholder="Enter username" autocomplete="username">
        <button type="button" id="fetch-games-btn" onclick="fetchChesscomGames()">
            üì• Fetch Games
        </button>
        <select id="num-games" class="num-games-select">
            <option value="5" selected>5 games</option>
            <option value="10">10 games</option>
            <option value="15">15 games</option>
            <option value="20">20 games</option>
        </select>
    </div>

    <div class="game-selection-container" id="game-selection-container" style="display: none;">
        <label for="game-dropdown">Select a game to analyze:</label>
        <select id="game-dropdown" onchange="loadSelectedGame()">
            <option value="">-- Select a game --</option>
        </select>
        <div id="game-details"></div>
    </div>

    <div class="container">
        <div class="panel">
            <h2>Input</h2>

            <div class="settings">
                <div class="setting-group">
                    <label>Analysis Depth</label>
                    <select id="depth">
                        <option value="10">10 (Fast ~2s/move)</option>
                        <option value="12" selected>12 (Balanced ~4s/move)</option>
                        <option value="15">15 (Accurate ~8s/move)</option>
                        <option value="18">18 (Deep ~15s/move)</option>
                    </select>
                </div>
                <div class="setting-group">
                    <label>Engine Source</label>
                    <select id="engineSource">
                        <option value="lichess">Lichess Cloud (Fast)</option>
                        <option value="stockfish" selected>Stockfish.js (Client)</option>
                    </select>
                </div>
            </div>

            <label style="display: block; margin-bottom: 8px; color: #888; font-size: 12px;">
                Paste PGN or moves (e.g., 1. e4 e5 2. Nf3 Nc6)
            </label>
            <textarea id="pgnInput" placeholder="1. e4 e5 2. Nf3 Nc6 3. Bb5 a6 4. Ba4 Nf6 5. O-O Be7 6. Re1 b5 7. Bb3 d6 8. c3 O-O"></textarea>

            <div style="margin-top: 15px;">
                <label style="display: block; margin-bottom: 8px; color: #888; font-size: 12px;">
                    Or analyze a single position (FEN)
                </label>
                <input type="text" id="fenInput" placeholder="rnbqkbnr/pppppppp/8/8/4P3/8/PPPP1PPP/RNBQKBNR b KQkq e3 0 1">
            </div>

            <div style="margin-top: 15px;">
                <button id="analyzeBtn" onclick="analyzeGame()" disabled>Analyze Game</button>
                <button id="analyzeFenBtn" onclick="analyzeFen()" disabled style="background: #0f3460; color: #00d4ff;">Analyze Position</button>
                <button onclick="clearResults()" style="background: #333; color: #888;">Clear</button>
            </div>

            <div class="progress-bar" id="progressBar" style="display: none;">
                <div class="progress-fill" id="progressFill"></div>
            </div>
        </div>

        <div class="panel">
            <h2>Results</h2>

            <div id="openingInfo" style="display: none; background: #0f3460; padding: 12px; border-radius: 8px; margin-bottom: 15px;">
                <div style="font-size: 12px; color: #888; margin-bottom: 4px;">Opening</div>
                <div style="font-weight: bold; color: #00d4ff;" id="openingName">-</div>
            </div>

            <div id="openingDeviations" style="display: none; margin-bottom: 15px;"></div>

            <div class="stats" id="statsContainer" style="display: none;">
                <div class="stat-box blunders">
                    <div class="stat-value" id="blunderCount">0</div>
                    <div class="stat-label">Blunders</div>
                </div>
                <div class="stat-box mistakes">
                    <div class="stat-value" id="mistakeCount">0</div>
                    <div class="stat-label">Mistakes</div>
                </div>
            </div>

            <div class="results" id="results">
                <p style="color: #888; text-align: center;">Enter a PGN and click Analyze to see results</p>
            </div>

            <!-- Analysis Report Container -->
            <div id="analysisReportContainer" style="display: none; margin-top: 15px; max-width: 800px; box-sizing: border-box;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; flex-wrap: wrap; gap: 8px;">
                    <span style="font-weight: bold; color: #00d4ff;">Full Analysis Report</span>
                    <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                        <button id="loadPgnFromHighlight" style="background: #17a2b8; color: white; border: none; padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 12px;">Load PGN from Highlight</button>
                        <button id="loadRefImageBtn" style="background: #17a2b8; color: white; border: none; padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 12px;">üñºÔ∏è Load Reference Image</button>
                        <input type="file" id="refImageFileInput" accept="image/*" style="display: none;">
                        <button id="toggleReportBtn" style="background: #0f3460; color: #00d4ff; padding: 6px 12px; font-size: 12px; border: none; border-radius: 6px; cursor: pointer;">Hide Report</button>
                    </div>
                </div>
                <div id="analysisReportText" style="
                    background: #ffffff;
                    color: #000000;
                    padding: 15px;
                    border-radius: 6px;
                    font-family: 'Courier New', monospace;
                    font-size: 14px;
                    line-height: 1.5;
                    max-height: 500px;
                    overflow-y: auto;
                    overflow-x: hidden;
                    white-space: pre-wrap;
                    word-wrap: break-word;
                    border: 1px solid #ccc;
                    box-sizing: border-box;
                ">Loading report...</div>
            </div>
        </div>
    </div>

    <!-- Report Loading Controls (horizontal layout) -->
    <div id="reportControls" style="margin: 20px auto; padding: 12px 15px; background: #16213e; border-radius: 8px; max-width: 1200px; display: flex; align-items: center; gap: 12px; flex-wrap: wrap;">
      <button id="loadAnalysisReport" style="background: #dc3545; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-weight: bold;">Load Analysis Report (from clipboard)</button>
      <button id="selectReportFolder" style="background: #28a745; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-weight: bold;" onclick="document.getElementById('reportFolderInput').click()">üìÇ Select Reports Folder</button>
      <input type="file" id="reportFolderInput" accept=".txt" webkitdirectory style="display: none;">
      <span id="reportsCountDisplay" style="color: #51cf66; font-weight: bold;"></span>
      <button id="viewPreloadedReports" style="background: #6f42c1; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-weight: bold; display: none;">üìã View Reports</button>
      <button id="saveReportBtn" style="background: #28a745; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-weight: bold;">üíæ Save Report</button>
    </div>

    <!-- Board and Navigation (horizontal layout) -->
    <div style="display: flex; gap: 20px; flex-wrap: wrap; margin: 20px auto; max-width: 1200px; align-items: flex-start;">
      <!-- Chess Board -->
      <div id="myBoard2" style="width: 400px; flex-shrink: 0;"></div>

      <!-- Board Navigation Container -->
      <div id="board2NavContainer" style="display: block; padding: 15px; background: #16213e; border-radius: 8px; flex: 1; min-width: 300px;">
        <div style="display: flex; align-items: center; gap: 12px; flex-wrap: wrap;">
          <button id="board2PrevMove" style="background: #00d4ff; color: #1a1a2e; border: none; padding: 10px 18px; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: bold;">‚Üê Prev</button>
          <span id="board2MoveIndicator" style="font-weight: bold; min-width: 60px; text-align: center; color: #eee;">Start</span>
          <button id="board2NextMove" style="background: #00d4ff; color: #1a1a2e; border: none; padding: 10px 18px; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: bold;">Next ‚Üí</button>
          <span style="color: #888;">Position: <span id="board2PositionCount" style="font-weight: bold; color: #eee;">0/0</span></span>
          <button id="flip_board2" style="background: #00d4ff; color: #1a1a2e; border: none; padding: 10px 18px; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: bold;">Flip Board</button>
          <a id="lichessBoard2Link" href="#" target="_blank" style="color: #00d4ff; text-decoration: underline;">Go to Lichess (Analysis)</a>
          <button id="loadPgnFromClipboard" style="background: #28a745; color: white; border: none; padding: 10px 18px; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: bold;">Load PGN from Clipboard</button>
        </div>
      </div>
    </div>

    <!-- Reference Image Modal -->
    <div id="refImageModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 1000;">
      <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #16213e; padding: 20px; border-radius: 8px; max-width: 90%; max-height: 90%;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
          <span style="font-weight: bold; color: #00d4ff;">Reference Image</span>
          <button id="closeRefImageModal" style="background: #dc3545; color: white; border: none; padding: 5px 15px; border-radius: 6px; cursor: pointer;">Close</button>
        </div>
        <div id="refImagePlaceholder" style="text-align: center; padding: 40px; color: #888;">No image loaded</div>
        <img id="refImagePreview" src="" alt="Reference Image" style="display: none; max-width: 100%; max-height: 70vh; cursor: zoom-in;">
      </div>
    </div>

    <!-- Report Files Modal -->
    <div id="reportFilesModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000;">
      <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #16213e; padding: 20px; border-radius: 8px; max-width: 600px; width: 90%; max-height: 80%; overflow-y: auto;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
          <h3 style="margin: 0; color: #00d4ff;">Select Report File</h3>
          <button id="closeReportFilesModal" style="background: #dc3545; color: white; border: none; padding: 5px 15px; border-radius: 6px; cursor: pointer;">Close</button>
        </div>
        <div id="reportFilesList" style="color: #eee;"></div>
      </div>
    </div>

    <div class="panel" style="margin-top: 20px;">
        <h2>Log</h2>
        <div id="log"></div>
    </div>

    <!-- jQuery (required for chessboard.js) -->
    <script src='https://code.jquery.com/jquery-2.2.4.min.js'></script>
    <!-- Chessboard.js -->
    <script src='https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.js'></script>
    <!-- Chess.js for move parsing (local) -->
    <script src="chess.min.js"></script>
    <!-- Chess analysis utilities (PGN to UCI conversion) -->
    <script src="analysis_chess.js"></script>

    <script>
        // =====================================================================
        // STOCKFISH.JS CLIENT-SIDE ENGINE
        // =====================================================================

        let stockfish = null;
        let isReady = false;
        let currentResolve = null;
        let analysisQueue = [];

        // Thresholds (in centipawns) - stricter thresholds
        const BLUNDER_THRESHOLD = 300;     // 3 pawns
        const MISTAKE_THRESHOLD = 150;     // 1.5 pawns

        // Initialize Stockfish Web Worker
        function initStockfish() {
            log('Initializing Stockfish.js...', 'info');

            try {
                // Load from local file (same directory as this HTML)
                stockfish = new Worker('stockfish.js');

                stockfish.onmessage = handleStockfishMessage;
                stockfish.onerror = (e) => {
                    log('Stockfish error: ' + e.message, 'error');
                };

                // Initialize UCI
                stockfish.postMessage('uci');

            } catch (e) {
                log('Failed to load Stockfish: ' + e.message, 'error');
                setStatus('error', 'Failed to load engine');
            }
        }

        function handleStockfishMessage(e) {
            const line = e.data;

            if (line === 'uciok') {
                log('Stockfish UCI initialized', 'success');
                stockfish.postMessage('isready');
            }
            else if (line === 'readyok') {
                isReady = true;
                setStatus('ready', 'Stockfish ready');
                document.getElementById('analyzeBtn').disabled = false;
                document.getElementById('analyzeFenBtn').disabled = false;
                document.getElementById('engineInfo').textContent = 'Stockfish.js (Client-side WASM)';
                log('Stockfish is ready!', 'success');
            }
            else if (line.startsWith('info depth')) {
                // Parse evaluation info
                const depthMatch = line.match(/depth (\d+)/);
                const scoreMatch = line.match(/score (cp|mate) (-?\d+)/);
                const pvMatch = line.match(/pv (.+)/);

                if (depthMatch && scoreMatch) {
                    const depth = parseInt(depthMatch[1]);
                    const scoreType = scoreMatch[1];
                    const scoreValue = parseInt(scoreMatch[2]);

                    // Update during analysis
                    if (depth >= 10) {
                        const evalStr = scoreType === 'mate'
                            ? `M${scoreValue}`
                            : (scoreValue / 100).toFixed(2);
                        // Could update UI here with intermediate results
                    }
                }
            }
            else if (line.startsWith('bestmove')) {
                // Analysis complete
                const bestMove = line.split(' ')[1];

                if (currentResolve) {
                    currentResolve({
                        bestMove: bestMove,
                        evaluation: currentEval
                    });
                    currentResolve = null;
                }
            }
        }

        let currentEval = 0;

        // Analyze a single position
        function analyzePosition(fen, targetDepth = 10) {
            return new Promise((resolve, reject) => {
                if (!isReady) {
                    reject(new Error('Stockfish not ready'));
                    return;
                }

                let finalEval = 0;
                let currentDepth = 0;
                let resolved = false;
                let timeoutId = null;

                const analysisHandler = (e) => {
                    const line = e.data;

                    // Capture evaluation at each depth
                    if (line.startsWith('info depth')) {
                        const depthMatch = line.match(/info depth (\d+)/);
                        const scoreMatch = line.match(/score (cp|mate) (-?\d+)/);

                        if (depthMatch && scoreMatch) {
                            const depth = parseInt(depthMatch[1]);
                            const scoreType = scoreMatch[1];
                            const scoreValue = parseInt(scoreMatch[2]);

                            // Only update if this is a deeper search
                            if (depth >= currentDepth) {
                                currentDepth = depth;
                                finalEval = scoreType === 'mate'
                                    ? (scoreValue > 0 ? 10000 - scoreValue : -10000 - scoreValue)
                                    : scoreValue;
                            }
                        }
                    }

                    // Analysis complete
                    if (line.startsWith('bestmove')) {
                        if (resolved) return;
                        resolved = true;
                        if (timeoutId) clearTimeout(timeoutId);

                        // Restore original handler
                        stockfish.onmessage = handleStockfishMessage;

                        resolve({
                            evaluation: finalEval,
                            depth: currentDepth
                        });
                    }
                };

                // Set up handler for this analysis
                stockfish.onmessage = analysisHandler;

                // Set up position and analyze
                stockfish.postMessage('position fen ' + fen);
                stockfish.postMessage('go depth ' + targetDepth);

                // Timeout after 15 seconds per move - resolve with current eval if no response
                timeoutId = setTimeout(() => {
                    if (resolved) return;
                    resolved = true;

                    stockfish.postMessage('stop');
                    stockfish.onmessage = handleStockfishMessage;

                    log('Position analysis timed out, using partial result', 'warning');
                    resolve({
                        evaluation: finalEval,
                        depth: currentDepth
                    });
                }, 15000);
            });
        }

        // =====================================================================
        // LICHESS OPENING EXPLORER API
        // =====================================================================

        async function getOpeningName(fen) {
            try {
                const response = await fetch(
                    `https://explorer.lichess.ovh/masters?fen=${encodeURIComponent(fen)}`
                );

                if (!response.ok) return null;

                const data = await response.json();

                if (data.opening) {
                    return {
                        eco: data.opening.eco,
                        name: data.opening.name
                    };
                }
                return null;
            } catch (e) {
                return null;
            }
        }

        async function getOpeningMoves(fen) {
            try {
                const response = await fetch(
                    `https://explorer.lichess.ovh/masters?fen=${encodeURIComponent(fen)}&topGames=0`
                );

                if (!response.ok) return null;

                const data = await response.json();

                if (data.moves && data.moves.length > 0) {
                    const totalGames = data.white + data.draws + data.black;
                    return {
                        moves: data.moves.slice(0, 5).map(m => ({
                            san: m.san,
                            games: m.white + m.draws + m.black,
                            percentage: totalGames > 0
                                ? ((m.white + m.draws + m.black) / totalGames * 100).toFixed(1)
                                : 0,
                            whiteWinRate: m.white + m.draws + m.black > 0
                                ? ((m.white / (m.white + m.draws + m.black)) * 100).toFixed(0)
                                : 0
                        })),
                        totalGames: totalGames,
                        opening: data.opening
                    };
                }
                return null;
            } catch (e) {
                return null;
            }
        }

        // =====================================================================
        // LICHESS CLOUD EVAL
        // =====================================================================

        async function lichessCloudEval(fen) {
            try {
                const response = await fetch(
                    `https://lichess.org/api/cloud-eval?fen=${encodeURIComponent(fen)}&multiPv=1`
                );

                if (response.status === 404) {
                    return null;
                }

                const data = await response.json();

                if (data.pvs && data.pvs[0]) {
                    const pv = data.pvs[0];
                    let score;

                    if (pv.mate !== undefined) {
                        score = pv.mate > 0 ? 10000 - pv.mate : -10000 - pv.mate;
                    } else {
                        score = pv.cp || 0;
                    }

                    return {
                        score: score,
                        bestMove: pv.moves ? pv.moves.split(' ')[0] : null,
                        source: 'lichess_cloud',
                        depth: data.depth
                    };
                }

                return null;
            } catch (e) {
                log('Lichess API error: ' + e.message, 'warning');
                return null;
            }
        }

        // =====================================================================
        // GAME ANALYSIS
        // =====================================================================

        async function analyzeGame() {
            let pgn = document.getElementById('pgnInput').value.trim();
            if (!pgn) {
                log('Please enter a PGN', 'error');
                return;
            }

            // Use AnalysisChess module if available, otherwise fallback
            if (typeof AnalysisChess !== 'undefined') {
                pgn = AnalysisChess.cleanPgn(pgn);
                log('Cleaned PGN using AnalysisChess module', 'info');
            } else {
                pgn = cleanPgn(pgn);
                log('Cleaned PGN of annotations', 'info');
            }

            const depth = parseInt(document.getElementById('depth').value);
            const useCloud = document.getElementById('engineSource').value === 'lichess';

            document.getElementById('analyzeBtn').disabled = true;
            document.getElementById('progressBar').style.display = 'block';
            document.getElementById('statsContainer').style.display = 'grid';
            document.getElementById('results').innerHTML = '<p style="color: #888;">Analyzing...</p>';

            setStatus('working', 'Analyzing...');
            log('Starting game analysis...', 'info');

            try {
                const chess = new Chess();

                // Try to load PGN
                if (!chess.load_pgn(pgn)) {
                    chess.reset();
                    const moves = pgn.replace(/\d+\./g, '').trim().split(/\s+/);
                    for (const move of moves) {
                        if (move && !chess.move(move)) {
                            throw new Error(`Invalid move: ${move}`);
                        }
                    }
                }

                const history = chess.history({ verbose: true });
                const totalMoves = history.length;

                // Log UCI moves if AnalysisChess is available
                if (typeof AnalysisChess !== 'undefined') {
                    const uciMoves = history.map(m => m.from + m.to + (m.promotion || ''));
                    log(`UCI moves: ${uciMoves.slice(0, 5).join(', ')}...`, 'info');
                }

                log(`Parsed ${totalMoves} moves`, 'info');

                // Detect opening and deviations from theory
                let openingInfo = null;
                let openingDeviations = [];
                let leftBook = false;
                let leftBookAtMove = null;

                const tempChess = new Chess();
                for (let i = 0; i < Math.min(history.length, 30); i++) {
                    const fenBefore = tempChess.fen();
                    const movePlayed = history[i].san;
                    const moveNum = Math.floor(i / 2) + 1;
                    const isWhite = i % 2 === 0;
                    const notation = isWhite ? `${moveNum}.` : `${moveNum}...`;

                    const bookData = await getOpeningMoves(fenBefore);

                    tempChess.move(movePlayed);

                    const opening = await getOpeningName(tempChess.fen());
                    if (opening) {
                        openingInfo = opening;
                    }

                    if (bookData && bookData.moves.length > 0 && !leftBook) {
                        const bookMoves = bookData.moves.map(m => m.san);
                        const isBookMove = bookMoves.includes(movePlayed);
                        const topMove = bookData.moves[0];

                        if (!isBookMove) {
                            leftBook = true;
                            leftBookAtMove = notation;

                            const mainLineMoves = bookData.moves.slice(0, 3)
                                .map(m => `${m.san} (${m.percentage}%)`)
                                .join(', ');

                            openingDeviations.push({
                                notation: notation,
                                movePlayed: movePlayed,
                                isWhite: isWhite,
                                mainLine: topMove.san,
                                mainLinePercentage: topMove.percentage,
                                alternatives: mainLineMoves,
                                totalGames: bookData.totalGames,
                                fen: fenBefore
                            });

                            log(`${notation} ${movePlayed}: Left opening theory! Main line was ${topMove.san} (${topMove.percentage}%)`, 'warning');
                        }
                    } else if (!bookData || bookData.moves.length === 0) {
                        if (!leftBook) {
                            leftBook = true;
                            leftBookAtMove = notation;
                        }
                    }
                }

                if (openingInfo) {
                    log(`Opening: ${openingInfo.eco} - ${openingInfo.name}`, 'success');
                }
                if (leftBookAtMove && openingDeviations.length === 0) {
                    log(`Left book at move ${leftBookAtMove} (end of theory)`, 'info');
                }

                chess.reset();

                const mistakes = [];
                let blunders = 0, mistakeCount = 0;

                log('Analyzing all positions...', 'info');
                const evaluations = [];

                let result;
                if (useCloud) {
                    const cloudResult = await lichessCloudEval(chess.fen());
                    result = cloudResult ? cloudResult.score : 0;
                } else {
                    const sfResult = await analyzePosition(chess.fen(), depth);
                    result = sfResult.evaluation;
                }
                evaluations.push(result);

                for (let i = 0; i < history.length; i++) {
                    chess.move(history[i].san);
                    const currentFen = chess.fen();

                    try {
                        if (useCloud) {
                            const cloudResult = await lichessCloudEval(currentFen);
                            result = cloudResult ? cloudResult.score : 0;
                        } else {
                            const sfResult = await analyzePosition(currentFen, depth);
                            result = sfResult.evaluation;
                        }
                    } catch (evalError) {
                        log(`Error evaluating move ${i + 1}: ${evalError.message}`, 'warning');
                        result = evaluations.length > 0 ? evaluations[evaluations.length - 1] : 0;
                    }
                    evaluations.push(result);

                    const progress = ((i + 1) / totalMoves) * 100;
                    document.getElementById('progressFill').style.width = progress + '%';

                    // Log progress every 10 moves or on last move
                    if ((i + 1) % 10 === 0 || i === history.length - 1) {
                        log(`Analyzed ${i + 1}/${totalMoves} positions...`, 'info');
                    }
                }

                chess.reset();

                log(`Evaluations complete: ${evaluations.length} positions analyzed`, 'info');
                log('Identifying mistakes...', 'info');
                for (let i = 0; i < history.length; i++) {
                    const move = history[i];
                    const moveNum = Math.floor(i / 2) + 1;
                    const isWhite = i % 2 === 0;
                    const notation = isWhite ? `${moveNum}.` : `${moveNum}...`;

                    const fenBefore = chess.fen();

                    let evalBefore = evaluations[i];
                    let evalAfter = evaluations[i + 1];

                    let swing;
                    let evalBeforeForDisplay, evalAfterForDisplay;

                    // Match analyze_game.js logic:
                    // Normalize scores to White's perspective, then calculate change
                    // based on who moved

                    if (useCloud) {
                        // Lichess Cloud: scores are from White's perspective
                        const prevWhiteScore = evalBefore;
                        const currWhiteScore = evalAfter;

                        if (isWhite) {
                            // White just moved: negative change = White got worse
                            swing = currWhiteScore - prevWhiteScore;
                            evalBeforeForDisplay = evalBefore;
                            evalAfterForDisplay = evalAfter;
                        } else {
                            // Black just moved: if White's score increased, Black got worse
                            swing = prevWhiteScore - currWhiteScore;
                            evalBeforeForDisplay = -evalBefore;
                            evalAfterForDisplay = -evalAfter;
                        }
                    } else {
                        // Stockfish.js: scores from side-to-move perspective
                        // evalBefore: from the mover's perspective (before they move)
                        // evalAfter: from opponent's perspective (after move)

                        // Convert to White's perspective
                        const prevWhiteScore = isWhite ? evalBefore : -evalBefore;
                        const currWhiteScore = isWhite ? -evalAfter : evalAfter;

                        if (isWhite) {
                            swing = currWhiteScore - prevWhiteScore;
                            evalBeforeForDisplay = prevWhiteScore;
                            evalAfterForDisplay = currWhiteScore;
                        } else {
                            swing = prevWhiteScore - currWhiteScore;
                            evalBeforeForDisplay = -prevWhiteScore;
                            evalAfterForDisplay = -currWhiteScore;
                        }
                    }

                    chess.move(move.san);

                    let severity = null;
                    if (swing <= -BLUNDER_THRESHOLD) {
                        severity = 'BLUNDER';
                        blunders++;
                    } else if (swing <= -MISTAKE_THRESHOLD) {
                        severity = 'MISTAKE';
                        mistakeCount++;
                    }

                    if (severity) {
                        mistakes.push({
                            notation: notation,
                            move: move.san,
                            severity: severity,
                            evalBefore: evalBeforeForDisplay,
                            evalAfter: evalAfterForDisplay,
                            swing: swing,
                            fen: fenBefore
                        });
                        log(`${notation} ${move.san}: ${severity} (${swing} cp)`,
                            severity === 'BLUNDER' ? 'error' : 'warning');
                    }
                }

                if (openingInfo) {
                    document.getElementById('openingInfo').style.display = 'block';
                    document.getElementById('openingName').textContent = `${openingInfo.eco}: ${openingInfo.name}`;
                } else {
                    document.getElementById('openingInfo').style.display = 'none';
                }

                const deviationsEl = document.getElementById('openingDeviations');
                if (openingDeviations.length > 0) {
                    let html = `
                        <div style="background: #1a1a2e; border: 1px solid #ffa94d; border-radius: 8px; padding: 12px;">
                            <div style="font-size: 12px; color: #ffa94d; margin-bottom: 8px; font-weight: bold;">
                                Opening Deviation
                            </div>
                    `;

                    for (const dev of openingDeviations) {
                        const fenEncoded = dev.fen.replace(/ /g, '_');
                        html += `
                            <div style="background: #0f3460; padding: 10px; border-radius: 6px; margin-bottom: 8px;">
                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                    <span style="font-weight: bold;">${dev.notation} ${dev.movePlayed}</span>
                                    <span style="font-size: 11px; background: #ffa94d; color: #1a1a2e; padding: 2px 6px; border-radius: 4px;">
                                        OUT OF BOOK
                                    </span>
                                </div>
                                <div style="margin-top: 8px; font-size: 13px; color: #aaa;">
                                    Main line: <strong style="color: #51cf66;">${dev.mainLine}</strong>
                                    <span style="color: #888;">(${dev.mainLinePercentage}% of ${dev.totalGames.toLocaleString()} master games)</span>
                                </div>
                                <div style="margin-top: 4px; font-size: 12px; color: #888;">
                                    Theory: ${dev.alternatives}
                                </div>
                                <div style="margin-top: 8px;">
                                    <a href="https://lichess.org/analysis/${fenEncoded}" target="_blank"
                                       style="font-size: 12px; color: #00d4ff; text-decoration: none;">
                                        Study this position on Lichess
                                    </a>
                                </div>
                            </div>
                        `;
                    }

                    html += '</div>';
                    deviationsEl.innerHTML = html;
                    deviationsEl.style.display = 'block';
                } else {
                    deviationsEl.style.display = 'none';
                }

                document.getElementById('blunderCount').textContent = blunders;
                document.getElementById('mistakeCount').textContent = mistakeCount;

                log('Generating report...', 'info');
                displayResults(mistakes, openingInfo, openingDeviations);

                setStatus('ready', 'Analysis complete');
                log(`Analysis complete: ${blunders} blunders, ${mistakeCount} mistakes`, 'success');
                log('Report generated successfully', 'success');

            } catch (e) {
                log('Analysis error: ' + e.message, 'error');
                setStatus('ready', 'Error - check log');
            }

            document.getElementById('analyzeBtn').disabled = false;
            document.getElementById('progressBar').style.display = 'none';
        }

        async function analyzeFen() {
            const fen = document.getElementById('fenInput').value.trim();
            if (!fen) {
                log('Please enter a FEN', 'error');
                return;
            }

            document.getElementById('analyzeFenBtn').disabled = true;
            setStatus('working', 'Analyzing position...');
            log('Analyzing position: ' + fen, 'info');

            try {
                const depth = parseInt(document.getElementById('depth').value);
                const useCloud = document.getElementById('engineSource').value === 'lichess';

                let result;
                if (useCloud) {
                    result = await lichessCloudEval(fen);
                    if (!result) {
                        log('Position not in Lichess cloud, trying Stockfish...', 'warning');
                        result = await analyzePosition(fen, depth);
                        result = { score: result.evaluation, bestMove: result.bestMove };
                    }
                } else {
                    const sfResult = await analyzePosition(fen, depth);
                    result = { score: sfResult.evaluation, bestMove: sfResult.bestMove };
                }

                const evalStr = (result.score / 100).toFixed(2);
                document.getElementById('results').innerHTML = `
                    <div class="result-item">
                        <div class="result-header">
                            <span class="move-info">Position Evaluation</span>
                            <span class="eval-change">${result.score > 0 ? '+' : ''}${evalStr}</span>
                        </div>
                        <div>Best move: <strong>${result.bestMove || 'N/A'}</strong></div>
                        <div style="margin-top: 8px;">
                            <a class="fen-link" href="https://lichess.org/analysis/${fen.replace(/ /g, '_')}" target="_blank">
                                Analyze on Lichess
                            </a>
                        </div>
                    </div>
                `;

                log(`Evaluation: ${evalStr} | Best: ${result.bestMove}`, 'success');
                setStatus('ready', 'Analysis complete');

            } catch (e) {
                log('Error: ' + e.message, 'error');
                setStatus('ready', 'Error');
            }

            document.getElementById('analyzeFenBtn').disabled = false;
        }

        function displayResults(mistakes, openingInfo, openingDeviations) {
            // Hide the old results div - we're using the report container now
            document.getElementById('results').innerHTML = '';

            // Show the report container
            const reportContainer = document.getElementById('analysisReportContainer');
            const reportText = document.getElementById('analysisReportText');
            reportContainer.style.display = 'block';

            // Count blunders and mistakes
            const blunders = mistakes.filter(m => m.severity === 'BLUNDER').length;
            const mistakeCount = mistakes.filter(m => m.severity === 'MISTAKE').length;

            // Build the report text (CLI-style format)
            let report = '';

            // Header
            report += '=' .repeat(70) + '\n';
            report += 'CHESS GAME ANALYSIS REPORT\n';
            report += `Generated: ${new Date().toLocaleString()}\n`;
            report += '=' .repeat(70) + '\n\n';

            // Opening info
            if (openingInfo) {
                report += `Opening: ${openingInfo.eco || ''} ${openingInfo.name || ''}\n\n`;
            }

            // Game PGN
            const pgnInput = document.getElementById('pgnInput').value.trim();
            if (pgnInput) {
                report += 'GAME PGN\n';
                report += '-'.repeat(70) + '\n';
                report += pgnInput + '\n\n';
            }

            // Summary
            report += 'SUMMARY\n';
            report += '-' .repeat(70) + '\n';
            report += `Blunders: ${blunders}\n`;
            report += `Mistakes: ${mistakeCount}\n`;
            report += `Opening deviations: ${openingDeviations ? openingDeviations.length : 0}\n\n`;

            // Opening deviations section
            if (openingDeviations && openingDeviations.length > 0) {
                report += 'OPENING DEVIATIONS\n';
                report += '-' .repeat(70) + '\n';
                for (const dev of openingDeviations) {
                    report += `${dev.notation} ${dev.movePlayed} (book: ${dev.mainLine} ${dev.mainLinePercentage}%)\n`;
                    report += `  Alternatives: ${dev.alternatives}\n`;
                    const fenEncoded = dev.fen.replace(/ /g, '_');
                    report += `  https://lichess.org/analysis/${fenEncoded}\n\n`;
                }
            }

            // Mistakes & Blunders section
            if (mistakes.length > 0) {
                report += 'MISTAKES & BLUNDERS\n';
                report += '-' .repeat(70) + '\n';
                for (const err of mistakes) {
                    const evalBeforeStr = (err.evalBefore / 100).toFixed(2);
                    const evalAfterStr = (err.evalAfter / 100).toFixed(2);
                    const swingStr = (err.swing / 100).toFixed(2);
                    report += `${err.severity}: ${err.notation} ${err.move}\n`;
                    report += `  Eval: ${evalBeforeStr} ‚Üí ${evalAfterStr} (${err.swing > 0 ? '+' : ''}${swingStr})\n\n`;
                }
            }

            // Recommended puzzles section
            report += '=' .repeat(70) + '\n';
            report += 'RECOMMENDED PUZZLES TO PRACTICE\n';
            report += '=' .repeat(70) + '\n\n';

            // Determine puzzle themes based on mistakes
            const puzzleThemes = getPuzzleRecommendations(mistakes);

            if (puzzleThemes.length > 0) {
                report += 'Based on your game, practice these puzzle themes on Lichess:\n\n';
                for (const puzzle of puzzleThemes) {
                    report += `üéØ ${puzzle.theme}\n`;
                    report += `   ${puzzle.description}\n`;
                    report += `   Practice: ${puzzle.url}\n`;
                    if (puzzle.isDaily) {
                        report += `   ‚≠ê Bonus: Today's featured puzzle!\n`;
                    }
                    report += '\n';
                }
            } else {
                report += 'Great job! No significant weaknesses detected.\n';
                report += 'Keep practicing at: https://lichess.org/training\n\n';
            }

            // Key positions section
            const keyPositions = mistakes.filter(m => m.severity === 'BLUNDER' || m.severity === 'MISTAKE');
            if (keyPositions.length > 0) {
                report += '=' .repeat(70) + '\n';
                report += 'KEY POSITIONS TO REVIEW\n';
                report += '=' .repeat(70) + '\n\n';
                report += 'Review these critical positions:\n\n';

                for (const err of keyPositions.slice(0, 5)) {
                    report += `Move ${err.notation} ${err.move}\n`;
                    const fenEncoded = err.fen.replace(/ /g, '_');
                    report += `  https://lichess.org/analysis/${fenEncoded}\n\n`;
                }
            }

            // Set the report text
            reportText.textContent = report;

            // Store for later access
            window.analysisReportRawText = report;

            // Load PGN into board2 for navigation (reuse pgnInput from above)
            if (pgnInput && typeof window.parsePgnToPositions === 'function') {
                // Clean the PGN before parsing
                let cleanedPgn = pgnInput;
                if (typeof AnalysisChess !== 'undefined') {
                    cleanedPgn = AnalysisChess.cleanPgn(pgnInput);
                } else {
                    cleanedPgn = cleanPgn(pgnInput);
                }

                window.studyReportPositions = window.parsePgnToPositions(cleanedPgn);
                window.studyReportPositionIndex = 0;

                if (window.studyReportPositions && window.studyReportPositions.length > 0) {
                    if (window.board2) {
                        window.board2.position(window.studyReportPositions[0]);
                        updateBoard2MoveIndicator(0);
                    }
                    log(`Loaded ${window.studyReportPositions.length} positions to board`, 'success');
                }
            }
        }

        function getPuzzleRecommendations(mistakes) {
            const puzzles = [];
            const blunderCount = mistakes.filter(m => m.severity === 'BLUNDER').length;
            const mistakeCount = mistakes.filter(m => m.severity === 'MISTAKE').length;

            // Add puzzles based on error patterns
            if (blunderCount >= 2) {
                puzzles.push({
                    theme: 'Hanging Piece',
                    description: 'Win material by capturing undefended pieces',
                    url: 'https://lichess.org/training/hangingPiece',
                    isDaily: false
                });
            }

            if (blunderCount + mistakeCount >= 3) {
                puzzles.push({
                    theme: 'Middlegame',
                    description: 'Tactical puzzles from the middlegame',
                    url: 'https://lichess.org/training/middlegame',
                    isDaily: false
                });
            }

            if (mistakes.length > 0) {
                puzzles.push({
                    theme: 'Fork',
                    description: 'Attack two or more pieces simultaneously',
                    url: 'https://lichess.org/training/fork',
                    isDaily: false
                });
            }

            // Always add daily puzzle as bonus
            puzzles.push({
                theme: 'Daily Puzzle',
                description: "Today's featured puzzle from Lichess",
                url: 'https://lichess.org/training/daily',
                isDaily: true
            });

            return puzzles;
        }

        // Fallback cleanPgn if AnalysisChess not loaded
        function cleanPgn(pgn) {
            let cleaned = pgn.replace(/\$\d+/g, '');
            cleaned = cleaned.replace(/\{[^}]*\}/g, '');
            cleaned = cleaned.replace(/\([^)]*\)/g, '');
            cleaned = cleaned.replace(/\[%[^\]]*\]/g, '');
            cleaned = cleaned.replace(/\s+/g, ' ').trim();
            return cleaned;
        }

        function clearResults() {
            document.getElementById('results').innerHTML =
                '<p style="color: #888; text-align: center;">Enter a PGN and click Analyze to see results</p>';
            document.getElementById('statsContainer').style.display = 'none';
            document.getElementById('openingInfo').style.display = 'none';
            document.getElementById('openingDeviations').style.display = 'none';
            document.getElementById('blunderCount').textContent = '0';
            document.getElementById('mistakeCount').textContent = '0';
            document.getElementById('progressFill').style.width = '0%';
            // Hide the report container
            document.getElementById('analysisReportContainer').style.display = 'none';
            document.getElementById('analysisReportText').textContent = 'Loading report...';
            window.analysisReportRawText = null;
        }

        // =====================================================================
        // UI HELPERS
        // =====================================================================

        function setStatus(status, text) {
            const dot = document.getElementById('statusDot');
            const textEl = document.getElementById('statusText');

            dot.className = 'status-dot';
            if (status === 'ready') dot.classList.add('ready');
            if (status === 'working') dot.classList.add('working');

            textEl.textContent = text;
        }

        function log(message, type = 'info') {
            const logEl = document.getElementById('log');
            const entry = document.createElement('div');
            entry.className = 'log-entry ' + type;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logEl.appendChild(entry);
            logEl.scrollTop = logEl.scrollHeight;
        }

        // =====================================================================
        // CHESS.COM GAME FETCHER
        // =====================================================================

        let fetchedGames = {};

        function validateUsername(username) {
            const pattern = /^[a-zA-Z0-9_]{3,25}$/;
            return pattern.test(username);
        }

        function extractPgnMoves(pgnText) {
            const lines = pgnText.split('\n');
            const moveLines = [];

            for (const line of lines) {
                const trimmed = line.trim();
                if (!trimmed || trimmed.startsWith('[')) {
                    continue;
                }
                moveLines.push(trimmed);
            }

            let movesText = moveLines.join(' ');
            movesText = movesText.replace(/\{[^}]*\}/g, '');
            movesText = movesText.replace(/\([^)]*\)/g, '');
            movesText = movesText.replace(/\[%[^\]]*\]/g, '');
            movesText = movesText.replace(/\s+/g, ' ').trim();

            return movesText;
        }

        function formatGameDate(timestamp) {
            if (!timestamp) return 'Unknown';
            const date = new Date(timestamp * 1000);
            return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
        }

        function showChesscomMessage(message, type) {
            clearChesscomMessages();

            const div = document.createElement('div');
            div.className = 'chesscom-message ' + type;
            div.textContent = message;

            const importBar = document.getElementById('chesscom-import-bar');
            importBar.parentNode.insertBefore(div, importBar.nextSibling);

            setTimeout(() => div.remove(), 5000);
        }

        function clearChesscomMessages() {
            const existing = document.querySelectorAll('.chesscom-message');
            existing.forEach(el => el.remove());
        }

        async function fetchChesscomGames() {
            const usernameInput = document.getElementById('chesscom-username');
            const fetchBtn = document.getElementById('fetch-games-btn');
            const gameSelectionContainer = document.getElementById('game-selection-container');
            const gameDropdown = document.getElementById('game-dropdown');
            const numGamesSelect = document.getElementById('num-games');

            const username = usernameInput.value.trim().toLowerCase();
            const numGames = parseInt(numGamesSelect.value);

            if (!username) {
                showChesscomMessage('Please enter a Chess.com username', 'error');
                return;
            }

            if (!validateUsername(username)) {
                showChesscomMessage('Invalid username format. Use 3-25 alphanumeric characters or underscores.', 'error');
                return;
            }

            clearChesscomMessages();
            fetchedGames = {};
            gameDropdown.innerHTML = '<option value="">-- Select a game --</option>';
            gameSelectionContainer.style.display = 'none';

            fetchBtn.disabled = true;
            fetchBtn.innerHTML = '<span class="chesscom-spinner"></span> Fetching...';
            log('Fetching games from Chess.com for: ' + username, 'info');

            try {
                const headers = { 'Accept': 'application/json' };
                let gamesList = [];

                const now = new Date();
                const year = now.getFullYear();
                const month = String(now.getMonth() + 1).padStart(2, '0');

                const archiveUrl = `https://api.chess.com/pub/player/${username}/games/${year}/${month}`;

                try {
                    const response = await fetch(archiveUrl, { headers });

                    if (response.status === 404) {
                        throw new Error('User not found on Chess.com. Check the username and try again.');
                    }

                    if (response.ok) {
                        const data = await response.json();
                        if (data.games) {
                            gamesList = gamesList.concat(data.games);
                        }
                    }
                } catch (e) {
                    if (e.message.includes('User not found')) throw e;
                }

                if (gamesList.length < numGames) {
                    let prevMonth = now.getMonth();
                    let prevYear = year;
                    if (prevMonth === 0) {
                        prevMonth = 12;
                        prevYear -= 1;
                    }

                    const prevUrl = `https://api.chess.com/pub/player/${username}/games/${prevYear}/${String(prevMonth).padStart(2, '0')}`;

                    try {
                        const prevResponse = await fetch(prevUrl, { headers });
                        if (prevResponse.ok) {
                            const prevData = await prevResponse.json();
                            if (prevData.games) {
                                gamesList = gamesList.concat(prevData.games);
                            }
                        }
                    } catch (e) {
                        // Ignore errors from previous month
                    }
                }

                if (gamesList.length === 0) {
                    showChesscomMessage('No games found for this user in the last 2 months.', 'info');
                    log('No games found for ' + username, 'warning');
                    return;
                }

                gamesList.sort((a, b) => (b.end_time || 0) - (a.end_time || 0));
                const recentGames = gamesList.slice(0, numGames);

                for (let idx = 0; idx < recentGames.length; idx++) {
                    const game = recentGames[idx];
                    if (!game.pgn) continue;

                    const white = game.white || {};
                    const black = game.black || {};
                    const whiteUsername = white.username || 'Unknown';
                    const blackUsername = black.username || 'Unknown';
                    const whiteResult = white.result || '';
                    const blackResult = black.result || '';

                    let opponent, resultDisplay, playerColor;
                    if (username.toLowerCase() === whiteUsername.toLowerCase()) {
                        opponent = blackUsername;
                        playerColor = 'White';
                        if (whiteResult === 'win') resultDisplay = 'Win';
                        else if (blackResult === 'win') resultDisplay = 'Loss';
                        else resultDisplay = 'Draw';
                    } else {
                        opponent = whiteUsername;
                        playerColor = 'Black';
                        if (blackResult === 'win') resultDisplay = 'Win';
                        else if (whiteResult === 'win') resultDisplay = 'Loss';
                        else resultDisplay = 'Draw';
                    }

                    const gameDate = formatGameDate(game.end_time);
                    const timeClass = game.time_class || 'unknown';

                    const label = `Game ${idx + 1}: vs ${opponent} (${resultDisplay} as ${playerColor}) - ${timeClass} - ${gameDate}`;

                    fetchedGames[label] = {
                        pgn: extractPgnMoves(game.pgn),
                        fullPgn: game.pgn,
                        metadata: {
                            white: whiteUsername,
                            black: blackUsername,
                            white_rating: white.rating || '?',
                            black_rating: black.rating || '?',
                            result: game.result || 'Unknown',
                            time_class: timeClass,
                            time_control: game.time_control || '',
                            url: game.url || '',
                            end_time: game.end_time
                        }
                    };
                }

                if (Object.keys(fetchedGames).length === 0) {
                    showChesscomMessage('No valid games found (games may be missing PGN data).', 'info');
                    return;
                }

                for (const label of Object.keys(fetchedGames)) {
                    const option = document.createElement('option');
                    option.value = label;
                    option.textContent = label;
                    gameDropdown.appendChild(option);
                }

                gameSelectionContainer.style.display = 'block';
                showChesscomMessage(`Found ${Object.keys(fetchedGames).length} recent games!`, 'success');
                log(`Fetched ${Object.keys(fetchedGames).length} games from Chess.com`, 'success');

            } catch (error) {
                showChesscomMessage(error.message || 'Failed to fetch games. Please try again.', 'error');
                log('Chess.com fetch error: ' + error.message, 'error');
                gameSelectionContainer.style.display = 'none';
            } finally {
                fetchBtn.disabled = false;
                fetchBtn.innerHTML = 'üì• Fetch Games';
            }
        }

        function loadSelectedGame() {
            const gameDropdown = document.getElementById('game-dropdown');
            const gameDetails = document.getElementById('game-details');
            const pgnTextarea = document.getElementById('pgnInput');

            const selectedLabel = gameDropdown.value;

            if (!selectedLabel || !fetchedGames[selectedLabel]) {
                gameDetails.innerHTML = '';
                return;
            }

            const game = fetchedGames[selectedLabel];
            const meta = game.metadata;

            gameDetails.innerHTML = `
                <p><strong>White:</strong> ${meta.white} (${meta.white_rating})</p>
                <p><strong>Black:</strong> ${meta.black} (${meta.black_rating})</p>
                <p><strong>Time Control:</strong> ${meta.time_class} (${meta.time_control})</p>
                <p><strong>Result:</strong> ${meta.result}</p>
                ${meta.url ? `<p><a href="${meta.url}" target="_blank">View on Chess.com ‚Üó</a></p>` : ''}
            `;

            pgnTextarea.value = game.pgn;
            log('Loaded game: ' + selectedLabel, 'info');
        }

        // =====================================================================
        // STUDY TOOL - BOARD2 AND REPORT FUNCTIONALITY
        // =====================================================================

        // Global variables for study tool
        window.studyReportRawText = '';
        window.studyReportPositions = [];
        window.studyReportPositionIndex = 0;
        window.loadedReportFiles = [];
        let refImageLoaded = false;
        let refImageIsEnlarged = false;

        // Piece theme path for chess board
        const pieceThemePath = 'https://chessboardjs.com/img/chesspieces/wikipedia/{piece}.png';

        /**
         * Parse PGN notation to array of FEN positions
         */
        window.parsePgnToPositions = function(pgnString) {
            const positions = [];
            try {
                const chess = new Chess();
                positions.push(chess.fen()); // Starting position

                // Clean PGN
                let cleanPgn = pgnString
                    .replace(/\{[^}]*\}/g, '') // Remove comments
                    .replace(/\([^)]*\)/g, '') // Remove variations
                    .replace(/\d+\.\.\./g, '') // Remove black move indicators
                    .replace(/\s+/g, ' ')
                    .trim();

                // Extract moves
                const moveRegex = /([KQRBN]?[a-h]?[1-8]?x?[a-h][1-8](?:=[QRBN])?|O-O-O|O-O)(?:\+|#)?/g;
                let match;

                while ((match = moveRegex.exec(cleanPgn)) !== null) {
                    const move = match[1];
                    try {
                        const result = chess.move(move, { sloppy: true });
                        if (result) {
                            positions.push(chess.fen());
                        }
                    } catch (e) {
                        console.warn('Invalid move:', move);
                    }
                }
            } catch (e) {
                console.error('Error parsing PGN:', e);
            }
            return positions;
        };

        /**
         * Update board2 move indicator display
         */
        function updateBoard2MoveIndicator(index) {
            const indicator = document.getElementById('board2MoveIndicator');
            const positionCount = document.getElementById('board2PositionCount');
            const lichessLink = document.getElementById('lichessBoard2Link');

            if (!indicator || !window.studyReportPositions) return;

            const total = window.studyReportPositions.length;
            if (positionCount) {
                positionCount.textContent = `${index + 1}/${total}`;
            }

            if (index === 0) {
                indicator.textContent = 'Start';
            } else {
                const moveNumber = Math.ceil(index / 2);
                const isWhiteMove = index % 2 === 1;
                indicator.textContent = isWhiteMove ? `${moveNumber}.` : `${moveNumber}...`;
            }

            // Update Lichess link
            if (lichessLink && window.studyReportPositions[index]) {
                const position = window.studyReportPositions[index];
                const colorToMove = (index % 2 === 0) ? 'w' : 'b';
                let fen = position.includes(' ') ? position : `${position} ${colorToMove} KQkq - 0 1`;
                lichessLink.href = `https://lichess.org/analysis/${fen.replace(/ /g, '_')}`;
            }
        }

        function board2NextMove() {
            if (!window.studyReportPositions || window.studyReportPositions.length === 0) return;
            window.studyReportPositionIndex++;
            if (window.studyReportPositionIndex >= window.studyReportPositions.length) {
                window.studyReportPositionIndex = window.studyReportPositions.length - 1;
            }
            if (window.board2) {
                window.board2.position(window.studyReportPositions[window.studyReportPositionIndex]);
            }
            updateBoard2MoveIndicator(window.studyReportPositionIndex);
        }

        function board2PrevMove() {
            if (!window.studyReportPositions || window.studyReportPositions.length === 0) return;
            window.studyReportPositionIndex--;
            if (window.studyReportPositionIndex < 0) {
                window.studyReportPositionIndex = 0;
            }
            if (window.board2) {
                window.board2.position(window.studyReportPositions[window.studyReportPositionIndex]);
            }
            updateBoard2MoveIndicator(window.studyReportPositionIndex);
        }

        /**
         * Load analysis report from content
         */
        function loadStudyReportFromContent(clipboardText, sourceName = 'clipboard') {
            if (!clipboardText || clipboardText.trim() === '') {
                log('No content to load', 'warning');
                return;
            }

            window.studyReportRawText = clipboardText;

            // Show report container and display content (use the original analysisReportContainer)
            const reportContainer = document.getElementById('analysisReportContainer');
            const reportText = document.getElementById('analysisReportText');

            if (reportContainer && reportText) {
                reportContainer.style.display = 'block';
                reportText.textContent = clipboardText;
            }

            // Extract PGN from report and load to board2
            let pgnMatch = clipboardText.match(/GAME PGN[\s\S]*?-{5,}\s*(1\.[^\n]+)/);
            if (pgnMatch && pgnMatch[1]) {
                let pgnText = pgnMatch[1].trim();
                pgnText = pgnText.replace(/\s+/g, ' ').trim();

                if (typeof window.parsePgnToPositions === 'function') {
                    window.studyReportPositions = window.parsePgnToPositions(pgnText);
                    window.studyReportPositionIndex = 0;

                    if (window.studyReportPositions && window.studyReportPositions.length > 0) {
                        if (window.board2) {
                            window.board2.position(window.studyReportPositions[0]);
                            updateBoard2MoveIndicator(0);
                        }
                    }
                }
            }

            log(`Loaded report from ${sourceName}`, 'success');
        }

        /**
         * Open report files modal
         */
        function openReportFilesModal() {
            const modal = document.getElementById('reportFilesModal');
            const filesList = document.getElementById('reportFilesList');

            if (!modal || !filesList) return;

            filesList.innerHTML = '';

            if (!window.loadedReportFiles || window.loadedReportFiles.length === 0) {
                filesList.innerHTML = '<p style="color: #888;">No report files loaded. Use "Select Reports Folder" to load files.</p>';
                modal.style.display = 'block';
                return;
            }

            window.loadedReportFiles.forEach((file, index) => {
                const fileItem = document.createElement('div');
                fileItem.style.cssText = 'display: flex; justify-content: space-between; align-items: center; padding: 10px; border-bottom: 1px solid #0f3460; cursor: pointer; border-radius: 4px;';
                fileItem.innerHTML = `
                    <span style="flex: 1;">${file.name}</span>
                    <button style="background: #00d4ff; color: #1a1a2e; border: none; padding: 5px 15px; border-radius: 3px; cursor: pointer; font-weight: bold;">Load</button>
                `;

                fileItem.addEventListener('mouseenter', () => fileItem.style.background = '#0f3460');
                fileItem.addEventListener('mouseleave', () => fileItem.style.background = 'transparent');

                fileItem.addEventListener('click', async () => {
                    try {
                        let content;
                        if (typeof file.text === 'function') {
                            content = await file.text();
                        } else if (file.content) {
                            content = file.content;
                        }

                        if (content) {
                            loadStudyReportFromContent(content, file.name);
                            modal.style.display = 'none';
                        }
                    } catch (err) {
                        console.error('Error loading file:', err);
                        alert('Failed to load file: ' + file.name);
                    }
                });

                filesList.appendChild(fileItem);
            });

            modal.style.display = 'block';
        }

        // Initialize on load
        window.onload = () => {
            log('Chess Analyzer loaded', 'info');
            if (typeof AnalysisChess !== 'undefined') {
                log('AnalysisChess module loaded', 'success');
            }
            initStockfish();

            // Toggle report button (original)
            document.getElementById('toggleReportBtn').addEventListener('click', function() {
                const reportText = document.getElementById('analysisReportText');
                const toggleBtn = document.getElementById('toggleReportBtn');

                if (reportText.style.display === 'none') {
                    reportText.style.display = 'block';
                    toggleBtn.textContent = 'Hide Report';
                } else {
                    reportText.style.display = 'none';
                    toggleBtn.textContent = 'Show Report';
                }
            });

            // Enter key triggers Chess.com fetch
            document.getElementById('chesscom-username').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    fetchChesscomGames();
                }
            });

            // =========================================================
            // STUDY TOOL INITIALIZATION
            // =========================================================

            // Initialize Board2
            window.board2 = Chessboard('myBoard2', {
                draggable: true,
                dropOffBoard: 'snapback',
                position: 'start',
                snapbackSpeed: 500,
                snapSpeed: 100,
                pieceTheme: pieceThemePath
            });

            // Board2 Navigation
            const board2NextBtn = document.getElementById('board2NextMove');
            if (board2NextBtn) {
                board2NextBtn.addEventListener('click', board2NextMove);
            }

            const board2PrevBtn = document.getElementById('board2PrevMove');
            if (board2PrevBtn) {
                board2PrevBtn.addEventListener('click', board2PrevMove);
            }

            // Flip Board 2
            const flipBoard2 = document.getElementById('flip_board2');
            if (flipBoard2) {
                flipBoard2.addEventListener('click', function() {
                    log('Flipping board 2', 'info');
                    window.board2.flip();
                });
            }

            // Load PGN from Clipboard
            const loadPgnFromClipboardBtn = document.getElementById('loadPgnFromClipboard');
            if (loadPgnFromClipboardBtn) {
                loadPgnFromClipboardBtn.addEventListener('click', async function() {
                    try {
                        const clipboardText = await navigator.clipboard.readText();
                        if (!clipboardText || clipboardText.trim() === '') {
                            alert('Clipboard is empty. Please copy a PGN first.');
                            return;
                        }

                        let pgnText = clipboardText.trim();
                        pgnText = pgnText.split('\n')
                            .filter(line => !line.trim().startsWith('['))
                            .join(' ')
                            .replace(/\s+/g, ' ')
                            .trim();

                        if (!/\d+\./.test(pgnText)) {
                            alert('Clipboard does not contain valid PGN.');
                            return;
                        }

                        if (typeof window.parsePgnToPositions === 'function') {
                            window.studyReportPositions = window.parsePgnToPositions(pgnText);
                            window.studyReportPositionIndex = 0;

                            if (window.studyReportPositions && window.studyReportPositions.length > 0) {
                                window.board2.position(window.studyReportPositions[0]);
                                updateBoard2MoveIndicator(0);
                                log(`Loaded ${window.studyReportPositions.length} positions from clipboard`, 'success');
                            }
                        }
                    } catch (err) {
                        console.error('Failed to read clipboard:', err);
                        alert('Could not read clipboard. Please check permissions.');
                    }
                });
            }

            // Keyboard Navigation for Board2
            document.addEventListener('keydown', function(e) {
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

                if (e.key === 'ArrowLeft') {
                    board2PrevMove();
                    e.preventDefault();
                } else if (e.key === 'ArrowRight') {
                    board2NextMove();
                    e.preventDefault();
                }
            });

            // Load Analysis Report from Clipboard
            const loadBtn = document.getElementById('loadAnalysisReport');
            if (loadBtn) {
                loadBtn.addEventListener('click', async function() {
                    try {
                        const clipboardText = await navigator.clipboard.readText();
                        loadStudyReportFromContent(clipboardText, 'clipboard');
                    } catch (err) {
                        console.error('Failed to read clipboard:', err);
                        alert('Could not read clipboard. Please check permissions.');
                    }
                });
            }

            // Report Folder Input Handler
            const reportFolderInput = document.getElementById('reportFolderInput');
            if (reportFolderInput) {
                reportFolderInput.addEventListener('change', async function(e) {
                    const files = Array.from(e.target.files);
                    const txtFiles = files.filter(file => file.name.toLowerCase().endsWith('.txt'));

                    if (txtFiles.length === 0) {
                        log('No .txt files found in selected folder', 'warning');
                        return;
                    }

                    txtFiles.sort((a, b) => a.name.localeCompare(b.name, undefined, { numeric: true, sensitivity: 'base' }));
                    window.loadedReportFiles = txtFiles;

                    const viewBtn = document.getElementById('viewPreloadedReports');
                    if (viewBtn) {
                        viewBtn.style.display = 'inline-block';
                    }

                    const countDisplay = document.getElementById('reportsCountDisplay');
                    if (countDisplay) {
                        countDisplay.textContent = `${txtFiles.length} Reports Loaded`;
                    }

                    log(`Loaded ${txtFiles.length} report files`, 'success');
                    openReportFilesModal();
                });
            }

            // View Reports Button
            const viewReportsBtn = document.getElementById('viewPreloadedReports');
            if (viewReportsBtn) {
                viewReportsBtn.addEventListener('click', openReportFilesModal);
            }

            // Close Modal Buttons
            const closeModalBtn = document.getElementById('closeReportFilesModal');
            if (closeModalBtn) {
                closeModalBtn.addEventListener('click', function() {
                    document.getElementById('reportFilesModal').style.display = 'none';
                });
            }

            const modal = document.getElementById('reportFilesModal');
            if (modal) {
                modal.addEventListener('click', function(e) {
                    if (e.target === modal) {
                        modal.style.display = 'none';
                    }
                });
            }

            // Save Report Button
            const saveReportBtn = document.getElementById('saveReportBtn');
            if (saveReportBtn) {
                saveReportBtn.addEventListener('click', function() {
                    const reportText = document.getElementById('analysisReportText');
                    if (reportText && reportText.textContent.trim() && reportText.textContent !== 'Loading report...') {
                        const content = reportText.textContent;
                        const blob = new Blob([content], { type: 'text/plain' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        const timestamp = new Date().toISOString().slice(0, 19).replace(/[T:]/g, '-');
                        a.download = `chess_analysis_report_${timestamp}.txt`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                    } else {
                        alert('No report content to save.');
                    }
                });
            }

            // Load PGN from Highlight Button
            const loadPgnFromHighlightBtn = document.getElementById('loadPgnFromHighlight');
            if (loadPgnFromHighlightBtn) {
                loadPgnFromHighlightBtn.addEventListener('click', function() {
                    const selection = window.getSelection();
                    const selectedText = selection.toString().trim();

                    if (!selectedText || selectedText === '') {
                        alert('No text is highlighted. Please highlight/select a PGN first.');
                        return;
                    }

                    let pgnText = selectedText;
                    pgnText = pgnText.split('\n')
                        .filter(line => !line.trim().startsWith('['))
                        .join(' ')
                        .replace(/\s+/g, ' ')
                        .trim();

                    if (!/\d+\./.test(pgnText)) {
                        alert('Selected text does not contain valid PGN.');
                        return;
                    }

                    if (typeof window.parsePgnToPositions === 'function') {
                        window.studyReportPositions = window.parsePgnToPositions(pgnText);
                        window.studyReportPositionIndex = 0;

                        if (window.studyReportPositions && window.studyReportPositions.length > 0) {
                            if (window.board2) {
                                window.board2.position(window.studyReportPositions[0]);
                                updateBoard2MoveIndicator(0);
                            }
                            log(`Loaded ${window.studyReportPositions.length} positions from highlighted PGN`, 'success');
                        }
                    } else {
                        alert('PGN parser not available.');
                    }
                });
            }

            // Load Reference Image Button
            const loadRefImageBtn = document.getElementById('loadRefImageBtn');
            if (loadRefImageBtn) {
                loadRefImageBtn.addEventListener('click', function() {
                    if (refImageLoaded) {
                        document.getElementById('refImageModal').style.display = 'block';
                    } else {
                        document.getElementById('refImageFileInput').click();
                    }
                });
            }

            // Reference Image File Input
            const refImageFileInput = document.getElementById('refImageFileInput');
            if (refImageFileInput) {
                refImageFileInput.addEventListener('change', function(e) {
                    const file = e.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = function(event) {
                            const img = document.getElementById('refImagePreview');
                            img.src = event.target.result;
                            img.style.display = 'block';
                            document.getElementById('refImagePlaceholder').style.display = 'none';
                            document.getElementById('loadRefImageBtn').textContent = 'üñºÔ∏è ' + file.name;
                            refImageLoaded = true;
                            document.getElementById('refImageModal').style.display = 'block';
                        };
                        reader.readAsDataURL(file);
                    }
                });
            }

            // Close Reference Image Modal
            const closeRefImageModalBtn = document.getElementById('closeRefImageModal');
            if (closeRefImageModalBtn) {
                closeRefImageModalBtn.addEventListener('click', function() {
                    document.getElementById('refImageModal').style.display = 'none';
                });
            }

            const refImageModal = document.getElementById('refImageModal');
            if (refImageModal) {
                refImageModal.addEventListener('click', function(e) {
                    if (e.target === refImageModal) {
                        refImageModal.style.display = 'none';
                    }
                });
            }

            // Reference Image Zoom Toggle
            const refImagePreview = document.getElementById('refImagePreview');
            if (refImagePreview) {
                refImagePreview.addEventListener('click', function() {
                    if (refImageIsEnlarged) {
                        this.style.maxWidth = '100%';
                        this.style.maxHeight = '70vh';
                        this.style.cursor = 'zoom-in';
                        refImageIsEnlarged = false;
                    } else {
                        this.style.maxWidth = 'none';
                        this.style.maxHeight = 'none';
                        this.style.cursor = 'zoom-out';
                        refImageIsEnlarged = true;
                    }
                });
            }

            log('Study tool initialized', 'success');
        };
    </script>
</body>
</html>
